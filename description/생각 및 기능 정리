1. 7개의 도형이 있음
2.  게임 진행 순서 생각해보기
    1. 필드 생성 및 세팅
    2. 5000개의 블럭 데이터 생성
    3. 블럭이 생성되며 시작
    4. n초마다 블럭 y-1
    5. 이동 후 0.5초 대기시간 후 각 블럭별(회전값 고려) 밑바닥 부분( image1 참고 )에서 y-1 좌표에 블럭이 있는지 or y좌표가 0은 아닌지 체크 allTrue check 후 멈춤
    6. 블럭이 가지고 있는 y좌표만 뽑아내서, 해당 y좌표가 다 찼는지 확인 후 삭제


3. 주어진 코드 분석
    ㅇ 전반적인 게임 진행에 관련된 큰 틀만 잡혀져있고, 정작 중요한 실행 함수와 데이터 구조 등은 없음
    -> 과제에서 요구하는건, '사전에 의도대로 정해져있는 문제를 해결하기위해 접근하는 과정을 보이는것'
    -> 설명해야 하는 코드이기에, 약간의 구조화와 직관적인 데이터 타입이 필요, 즉 협업과 유사한 구조
    -> 가이드와 ai봇을 통해, 내가 짠 구조 내에서, 가장 알맞은 위치를 알려주는 해법 알고리즘 또한 필요하다는것을 파악

4. 개발하며 생각 정리
    - 우선, 개발 시작점이 createBlock 를 포함한 각종 함수들이다. Block의 데이터구조부터 생각해보자
        -> (약속) 블록에 대한 모든 비교, 회전 등에 대한 절대적, 상대적 위치 기준은 가운데가 아닌 왼쪽 위(0,0)가 기준
        -> 각 상대적 위치에 해당하는 좌표 (blockSet)를 포함해야 한다.
        -> 포함해야 하는 정보
            ㅇ 어느 gameBox의 블럭인지
            ㅇ 블록을 구성하는 좌표들의 집합(blocks)
            ㅇ 맵에서의 현재 postion (x,y)
            ㅇ 색상정보
    - 이후, createBlock 함수 등을 실행시키면, 함수가 실행되도 되는지 조건을 검사하고, Block의 method를 실행시키자
    - 회전 :     
        -> 왼쪽 위 기준 relative 좌표 [0,0] 중심으로 돌리다보니 많이 많이 부자연스럽다. 각 도형별로 중앙지점을 정해주자니, 기존 [0,0] ~ [x,y] 지점까지 도형을 생성하는 방식에서, BFS방식으로 도형을 생성시켜야한다.
        -> 복잡한 BFS보다는, 90도 회전했을때 내가 원하는 지점과 얼마나 x,y값이 차이나는지 확인후 그만큼 더해주었다 (90도 돌렸을때 오른쪽으로 2칸 지점에 있었으면 좋겠다. = [x, - y +2]) 
           -y +2가 x가 되는것이니 y에서 더해주어야한다
        -> 상하대칭 형태인 꼬불이와 ㅣ 도형은 2가지 형태가 toggle 되도록 [y, x] = [x, y]
        -> 상하비대칭 형식인 니은과 ㅗ 도형은 4가지 형태가 toggle 되도록 [y, x] = [x, -y]
        
    - z 기능 :
        -> 주변 블럭을 탐색해서 바닥에 도착했는지 확인하는 moveEnd 함수가 먼저 필요하다
        -> moveEnd 의 조건이 false라면 밑으로 1칸 move 시키는것을 반복한다
        -> 성능을 고려한다면, 블럭의 밑부분과 바닥간의 거리 중 min 값만큼 밑으로 이동시키면 되나, 기존 블럭정보를 저장하지않고 css bgcolor 여부로 탐색하는 설계에서는 사실 큰 차이가없다고 판단 둘다 O(n제곱)의 시간복잡도이다

    - moveEnd : 이동종료?
        -> 각 x별 좌표마다 가장 낮은 y좌표에 있는 blocks list를 추출하고, blocks list 밑에 블럭이 있는 경우가 한개라도 있다면, 더이상 움직일 수 없는 상태로 판정
    - isFull : 해당 줄이 다 차서 삭제되어야 하나요?
        -> blocks가 moveEnd한 y좌표 list에 해당하는 줄이 다 찼는지 확인한다, 해당줄에 있는 모든 td의 색상이 white가 아닌경우 줄 삭제

    - AI 상대와 가이드 :
        -> 가이드가 만약 지울 수 있는 블럭이 있을때만 알려주는 구조라면 AI 알고리즘을 공유하지않는다
        -> 여러가지 방법을 고민해봤으나 ai를 어떻게 구현할것인가? 에 대한 완벽한 해답은 없는것 같다, 그냥 생각한 바를 기록한다.
            1. 알고리즘을 토대로 모든 경우의 수(회전 상태의 경우의 수 포함)를 각 기준에 맞게 평가한다.
                > 블럭이 쌓인 높이
                > 제거될 줄 수
                > 우물안에 빈 공간의 개수 (테트리스는 보통 양쪽 사이드부터 채워서 우물을 1개로 만드는게 유리한듯?)
                > 우물의 총 개수
            2. 가장 높은 점수를 받은 해의 값을 최적해로 두고, 블럭이 생성된 후 n초마다 최적해의 x값으로 이동, 회전하며, 최적해의 회전값에 도달한다.
            3. dropBlock()을 사용해 내린다.
            
.etc
    - 나의 최고점수 플레이를 재현하는 auto와 싸우거나, 일정점수 이상의 유저의 시간별 입력 데이터를 서버에 저장하고 그중 랜덤으로 수신해서 타인과 대결하는 기능을?
    - class로 구현하고 함수를 메소드로 이동시키면, 블럭이 동시에 여러개 떨어지게도 구현할 수 있다, 5초에 블럭이 한개씩 추가되는건 어떤가?
    - 회전 다만들고 나니 예제코드에 공식이 나와있었는걸 발견함...
.etc2
    - blockSet 좌표데이터가 이상하다 싶었더니, size40기준으로 0,0에서 생성시키면 가운데서 블럭들이 생성되게 배려해준것이었다. 하지만 본인은 size를 변경해도
      중앙에 있게 하고싶으니 -4 or -5 랜덤으로 x값을 빼서 정상적으로 변경해주자
    
    - 예제코드의 Row와 Col이 바뀌어서 사용되고 있다. 본인도 x랑 y 바꿔서 만들기로 결정
    - 블럭이 움직일 수 있는가? 에 대한 검증 코드를 너무 쉽게 보고 코드가 더러워졌다.
      뒤늦게 블럭상태 또는 위치가 변환되는 상태에서 일괄적으로 검증하고 return 하는 bgcolortranction 함수를 만들었지만, 기존 코드를 다 리팩토링해야하니.. 회전에만 적용

.issue
    - etc-1 내용 이후 rotate에서 어떻게 돌릴까 고민하던 중, [y, x] = [x, -y] 의 형태로 돌려버리니, blockSet의 중앙 세팅이 문제되서, 숫자를 작게 만들었다.
    - 회전할때, 벽을뚫거나 하는 버그가 발생
.task
    - 게임오버 d
    - 줄 지우기 ㅇ
    - 점수 측정 ㅇ
    - 좌우이동 버그 ㅇ
    - 벽이나 블럭 붙어서 회전할경우 뚫는버그 ㅇ
    - ㄹ 모양이 180도 대칭으로 회전하는 버그